\section{Related Work}

\subsection{Static Analysis}

\citeauthor{barr}~\cite{barr} built Ariadne. Ariadne applies symbolic execution to statically detect floating-point related bugs. Ariadne statically discovers occurrences of underflow, overflow, and arguments outside a function's domain, including division-by-zero. Ariadne converts C, C++, and Fortran programs to a real number companion program that makes explicit the possibility of floating-point errors. Ariadne discovers real number constraints that trigger the explicit floating-point errors using symbolic execution, an SMT solver, and a custom algorithm for solving non-linear constraints. Finally, Ariadne converts the real number constraints to floating-point numbers that witness the bugs.

Ariadne does not require test inputs nor does it actually execute the program - these are two improvements over our contribution, Real Semantics. However, Ariadne does not detect accumulated floating-point imprecision that modifies program behavior relative to the real number values while Real Semantics does. Moreover, Ariadne requires sophisticated tools and techniques to create and solve real number constraints.

\subsection{Formal Verification}

\citeauthor{boldo}~\cite{boldo} present a formal approach using Coq to verify floating-point programs. In contrast to Real Semantics and Ariadne, Boldo, et al. attempt to prove the non-existence of floating-point bugs. Moreover, they prove error bounds on the outputs of floating-point valued functions. Their work does not support the verification of programs using transcendental functions, such as sine and cosine.

Very recently, \citeauthor{verifiedfp}~\cite{verifiedfp} extended the CompCert compiler with a verified correct translation of IEEE-754 floating-point semantics into hardware. This is an important step towards verified correct floating-point computation because we can now trust that correct floating-point implementations in C will be compiled to correct machine code.

A major component of the work of \citeauthor{verifiedfp}~\cite{verifiedfp} was a formally specified semantics of IEEE-754 floating-point arithmetic. Interestingly, there did not previously exist such a rigorous, machine digestible definition of the IEEE standard.

Verification is an attractive alternative for critical systems, however, current methods are impractical for large programs owing both to the reasoning complexity and the necessary human effort.

\subsection{Precise By Construction}

\citeauthor{herbie}~\cite{herbie} developed Herbie. Herbie is a tool for automatically improving the accuracy of floating-point programs. The user specifies a numeric expression in a simple s-expression language. Herbie then performs rounds of testing random floating-point values and applying a table of known mathematical identities. Finally, Herbie outputs an expression that is equivalent on the reals, but more precise on the floating-point numbers.

Of the programs generated by Herbie, after conversion to C and compilation with GCC, the median program is 40\% slower than the unadultered programs. However, the generated programs are impressively more accurate; often achieving nearly maximum accuracy for the given floating-point format. Unfortunately, Herbie is necessarily limited to purely mathematical expressions. It cannot comprehend nor improve full programs in Turing-complete languages. Our tool, Real Semantics, complements Herbie by following the propagation of floating-point imprecision through imperative code.
